//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>

// include header generated by makeheaders
#include "psrthyme-fitter.hpp"

#if INTERFACE
#include <vector>
#include <map>
#include <boost/shared_ptr.hpp>

class PsrthymeFitter {
   private:
	  struct Itteration{
		 uint64_t resolution;
		 bool cholesky;
		 bool zoom;
		 Itteration(uint64_t resolution, bool cholesky, bool zoom){
			this->resolution = resolution;
			this->cholesky = cholesky;
			this->zoom = zoom;
		 }
	  };
	  PsrthymeTemplate::Ptr tmpl;
	  SparseList::Ptr chisq_space;
	  std::list<Itteration> itterations;
   public:
	  PsrthymeFitter() {
		 this->chisq_space = SparseList::Ptr(new SparseList(0,1,8));
		 this->useDefaults();
	  } 
	  void setTemplate(PsrthymeTemplate::Ptr tmpl){
		 this->tmpl = tmpl;
	  }
	  void useDefaults(){
		 this->clear();
		 this->itterations.push_front(Itteration(32,true,true));
		 this->itterations.push_front(Itteration(8,true,true));
		 this->itterations.push_front(Itteration(1,true,false));
		 this->itterations.push_front(Itteration(1,true,false));
		 this->itterations.push_front(Itteration(1,false,false));
	  }
	  void clear(){
		 this->itterations.clear();
		 this->chisq_space->clear();
	  }
	  void addItteration(uint64_t res, bool cholesky, bool zoom){
		 this->itterations.push_back(Itteration(res,cholesky,zoom));
	  }
	  PsrthymeResult::Ptr fitTo(PsrthymeObservation::Ptr obs);
};

#endif

std::vector<double> getCovarianceFunction (const std::vector<double> &profile){
   uint64_t i,j;
   const uint64_t nbins = profile.size();
   std::vector<double> cov(profile);
   double mean=0;
   for(i = 0; i < nbins; i++){
	  mean+=profile[i];
	  cov[i]=0;
   }
   mean /= double(nbins);
   for(j = 0; j < nbins; j++){
	  for(i = 0; i < nbins; i++){
		 cov[j] += (profile[i]-mean)*(profile[(i+j)%nbins]-mean);
	  }
   }
   for(i = 0; i < nbins; i++){
	  cov[i] /= double(nbins);
   }

   return cov;
}



PsrthymeResult::Ptr PsrthymeFitter::fitTo(PsrthymeObservation::Ptr obs){
   std::list<Itteration> ittrs(this->itterations);
   const uint64_t nbins = obs->getNbins();
   const uint64_t nfit = this->tmpl->size()+1;
   std::vector<double> residuals(obs->profile);
   while(ittrs.size() > 0){
	  Itteration itr = ittrs.front();
	  ittrs.pop_front();
	  const uint64_t nphase_steps = nbins * itr.resolution;
	  const double prev_best_phase=this->chisq_space->min();
	  const double prev_best_chisq=this->chisq_space->get(prev_best_phase);
	  const double chisq_cut = prev_best_chisq*3.0;
	  std::map<uint64_t, std::vector<double> > yvals;
	  std::map<uint64_t, std::vector<double> > white_yvals;

	  std::map<uint64_t, PsrthymeMatrix::Ptr > designMatricies;
	  std::map<uint64_t, PsrthymeMatrix::Ptr > white_designMatricies;

	  PsrthymeMatrix::Ptr uinv = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins));
	  std::vector<double> cov = getCovarianceFunction(residuals);
	  if (itr.cholesky) {
		 uinv->addCVF(cov);
		 uinv->addDiagonal(cov[0]*1e-9);
	  } else {
		 uinv->addDiagonal(cov[0]);
	  }

	  this->chisq_space->setResolution(nphase_steps);

	  for(uint64_t iphase = 0; iphase < nphase_steps; iphase++){
		 double phase = double(iphase)/double(nphase_steps);
		 if(!itr.zoom || this->chisq_space->get(phase) < chisq_cut){
			uint64_t ibin = iphase/itr.resolution;
			uint64_t sbin = iphase-ibin*itr.resolution;
			if ( yvals.count(ibin) == 0 ) {
			   // need to generate the rotated profile
			   std::vector<double> rotated(obs->profile);
			   std::rotate(rotated.begin(),rotated.begin()+ibin,rotated.end());
			   white_yvals[ibin] = (*uinv)*rotated;
			   yvals[ibin] = rotated;
			}
			if ( designMatricies.count(sbin) == 0 ) {
			   // need to generate the DM for this sub-phase
			   PsrthymeMatrix::Ptr dm = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins,nfit));
			}
		 }
	  }
   }
   PsrthymeResult::Ptr result = PsrthymeResult::Ptr(new PsrthymeResult());
   return result;
}
