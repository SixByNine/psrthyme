//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include "levmar/levmar.h"
#include <TKlog.h>

// include header generated by makeheaders
#include "LevMar.hpp"

#if INTERFACE
#include <boost/shared_ptr.hpp>
#include <vector>

template <typename T>
class LevMar {
   private:
   public:
	  std::vector<T> evaluate(std::vector<T> p);
	  std::vector<T> jacobian(std::vector<T> p);

};

#endif

using std::vector;

// PRIVATE callback functions to pass to the levmar library
extern "C" void lm_callback_func_d(double *p, double *hx, int m, int n, void *adata);
extern "C" void lm_callback_jacf_d(double *p, double *j, int m, int n, void *adata);
extern "C" void lm_callback_func_s(float *p, float *hx, int m, int n, void *adata);
extern "C" void lm_callback_jacf_s(float *p, float *j, int m, int n, void *adata);


/**
 * Callbacks from C to C++
 */
void lm_callback_func_d(double *p, double *hx, int m, int n, void *adata){
   const vector<double> _p = vector<double>(p,p+m);
   vector<double>_hx = ((LevMar<double>*)adata)->evaluate(_p);
   std::copy(_hx.begin(),_hx.end(),hx);
}
void lm_callback_jacf_d(double *p, double *j, int m, int n, void *adata){
   const vector<double> _p = vector<double>(p,p+m);
   vector<double>_j = ((LevMar<double>*)adata)->jacobian(_p);
   std::copy(_j.begin(),_j.end(),j);
}
void lm_callback_func_d(float *p, float *hx, int m, int n, void *adata){
   const vector<float> _p = vector<float>(p,p+m);
   vector<float>_hx = ((LevMar<float>*)adata)->evaluate(_p);
   std::copy(_hx.begin(),_hx.end(),hx);
}
void lm_callback_jacf_d(float *p, float *j, int m, int n, void *adata){
   const vector<float> _p = vector<float>(p,p+m);
   vector<float>_j = ((LevMar<float>*)adata)->jacobian(_p);
   std::copy(_j.begin(),_j.end(),j);
}

