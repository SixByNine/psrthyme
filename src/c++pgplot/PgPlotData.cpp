//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>
#include <cpgplot.h>

// include header generated by makeheaders
#include "PgPlotData.hpp"

#if INTERFACE
#include <boost/shared_ptr.hpp>
#include <vector>
class PgPlotData {
   protected:
	  void plotline();
	  void plothist();
	  void plotpoint();
	  void ploterror();
   public:
	  typedef boost::shared_ptr<PgPlotData> Ptr;
	  PgPlotData(); // constructor
	  int_fast16_t pointType;
	  double pointSize;
	  int_fast16_t pointColorIndex;
	  int_fast16_t lineType;
	  double lineWidth;
	  int_fast16_t lineColorIndex;
	  std::vector<double> x;
	  std::vector<double> y;
	  std::vector<double> e;
	  bool as_line;
	  bool as_hist;
	  bool as_point;
	  bool as_error;
	  void draw();
	  double xmax(){
		 return *std::max_element(this->x.begin(),this->x.end());
	  }
	  double xmin(){
		 return *std::min_element(this->x.begin(),this->x.end());
	  }
	  double ymax(){
		 return *std::max_element(this->y.begin(),this->y.end());
	  }
	  double ymin(){
		 return *std::min_element(this->y.begin(),this->y.end());
	  }

}

#endif
PgPlotData::PgPlotData() {
   this->pointType=0;
   this->pointSize=1;
   this->pointColorIndex=1;
   this->lineType=1;
   this->lineWidth=1;
   this->lineColorIndex=1;
   this->as_line=false;
   this->as_point=true;
   this->as_hist=true;
   this->as_error=false;
}

void PgPlotData::plotline() {
   cpgsci(this->lineColorIndex);
   cpgsls(this->lineType);
   cpgslw(this->lineWidth);
   cpgmove(x[0],y[0]);
   const uint64_t npts = this->x.size();
   for (uint64_t ipt = 0; ipt < npts; ipt++){
	  cpgdraw(x[ipt],y[ipt]);
   }
}

void PgPlotData::plotpoint() {
   cpgsci(this->pointColorIndex);
   cpgsch(this->pointSize);
   cpgmove(x[0],y[0]);
   const uint64_t npts = this->x.size();
   for (uint64_t ipt = 0; ipt < npts; ipt++){
	  cpgpt1(x[ipt],y[ipt],this->pointType);
   }
}
void PgPlotData::plothist() {
   cpgsci(this->lineColorIndex);
   cpgsls(this->lineType);
   cpgslw(this->lineWidth);
   cpgmove(x[0],y[0]);
   const uint64_t nptsm1 = this->x.size()-1;
   double bw = x[1]-x[0];
   for (uint64_t ipt = 0; ipt < nptsm1; ipt++){
	  cpgdraw(x[ipt]-bw/2.0,y[ipt]);
	  bw=x[ipt+1]-x[ipt];
	  cpgdraw(x[ipt]+bw/2.0,y[ipt]);
   }
   cpgdraw(x[nptsm1]-bw/2.0,y[nptsm1]);
   cpgdraw(x[nptsm1]+bw/2.0,y[nptsm1]);
}


void PgPlotData::draw() {
   if (as_line) this->plotline();
   if (as_hist) this->plothist();
   if (as_point) this->plotpoint();
}

