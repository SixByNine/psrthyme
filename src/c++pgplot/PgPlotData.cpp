//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>
#include <map>
#include <cpgplot.h>

// include header generated by makeheaders
#include "PgPlotData.hpp"

#if INTERFACE
#include <boost/shared_ptr.hpp>
#include <vector>
class PgPlotData {
   protected:
	  void orderData();
	  void plotline();
	  void plothist();
	  void plotpoint();
	  void ploterror();
	  uint64_t plot_type;
   public:
	  typedef boost::shared_ptr<PgPlotData> Ptr;
	  static Ptr blank();
	  PgPlotData(); // constructor
	  int_fast16_t pointType;
	  double pointSize;
	  int_fast16_t pointColorIndex;
	  int_fast16_t lineType;
	  double lineWidth;
	  int_fast16_t lineColorIndex;
	  bool order;
	  std::vector<double> x;
	  std::vector<double> y;
	  std::vector<double> e;
	  typedef enum _PgPlotType {NOPLOT=0,LINE=1,HIST=2,POINT=4,ERROR=8} PgPlotType;

	  void setPlotType(PgPlotType t){
		 this->plot_type=t;
	  }
	  void addPlotType(PgPlotType t){
		 this->plot_type |= t;
	  }
	  void removePlotType(PgPlotType t){
		 this->plot_type &= ~t;
	  }
	  void draw();
	  double xmax(){
		 return *std::max_element(this->x.begin(),this->x.end());
	  }
	  double xmin(){
		 return *std::min_element(this->x.begin(),this->x.end());
	  }
	  double ymax(){
		 return *std::max_element(this->y.begin(),this->y.end());
	  }
	  double ymin(){
		 return *std::min_element(this->y.begin(),this->y.end());
	  }

}

#endif
PgPlotData::PgPlotData() {
   this->pointType=0;
   this->pointSize=1;
   this->pointColorIndex=1;
   this->lineType=1;
   this->lineWidth=1;
   this->lineColorIndex=1;
   this->setPlotType(PgPlotData::POINT);
   this->order=true;
}

void PgPlotData::plotline() {
   cpgsci(this->lineColorIndex);
   cpgsls(this->lineType);
   cpgslw(this->lineWidth);
   cpgmove(x[0],y[0]);
   const uint64_t npts = this->x.size();
   for (uint64_t ipt = 0; ipt < npts; ipt++){
	  cpgdraw(x[ipt],y[ipt]);
   }
}

void PgPlotData::plotpoint() {
   cpgsci(this->pointColorIndex);
   cpgsch(this->pointSize);
   cpgmove(x[0],y[0]);
   const uint64_t npts = this->x.size();
   for (uint64_t ipt = 0; ipt < npts; ipt++){
	  cpgpt1(x[ipt],y[ipt],this->pointType);
   }
}
void PgPlotData::plothist() {
   cpgsci(this->lineColorIndex);
   cpgsls(this->lineType);
   cpgslw(this->lineWidth);
   cpgmove(x[0],y[0]);
   const uint64_t nptsm1 = this->x.size()-1;
   double bw = x[1]-x[0];
   for (uint64_t ipt = 0; ipt < nptsm1; ipt++){
	  cpgdraw(x[ipt]-bw/2.0,y[ipt]);
	  bw=x[ipt+1]-x[ipt];
	  cpgdraw(x[ipt]+bw/2.0,y[ipt]);
   }
   cpgdraw(x[nptsm1]-bw/2.0,y[nptsm1]);
   cpgdraw(x[nptsm1]+bw/2.0,y[nptsm1]);
}


void PgPlotData::draw() {
   if (this->order) this->orderData();
   if (this->plot_type & PgPlotData::LINE) this->plotline();
   if (this->plot_type & PgPlotData::HIST) this->plothist();
   if (this->plot_type & PgPlotData::POINT) this->plotpoint();
}

PgPlotData::Ptr PgPlotData::blank(){
   PgPlotData::Ptr blank = PgPlotData::Ptr(new PgPlotData());
   return blank;
}


void PgPlotData::orderData(){
   std::map<double,uint64_t> idx;
   std::vector<double> newx;
   std::vector<double> newy;
   for (uint64_t i =0; i < this->x.size(); i++){
	  idx[this->x[i]] = i;
   }
   for (std::map<double,uint64_t>::iterator it = idx.begin();
		 it != idx.end() ; ++it){
	  newx.push_back(this->x[it->second]);
	  newy.push_back(this->y[it->second]);
   }
   this->x.swap(newx);
   this->y.swap(newy);
}
