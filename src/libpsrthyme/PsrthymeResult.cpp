//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <TKlog.h>
#include <boost/format.hpp>

// include header generated by makeheaders
#include "PsrthymeResult.hpp"

#if INTERFACE
#include <vector>
#include <list>
#include <MJD.h>
#include <boost/shared_ptr.hpp>
class PsrthymeResult {
   public:
	  typedef boost::shared_ptr<PsrthymeResult> Ptr;
	  SparseList::Ptr chisq_space;
	  PsrthymeTemplate::Ptr tmpl;
	  PsrthymeProfile::Ptr obsn;
	  std::vector<double> amp_values;
	  std::vector<double> amp_errors;
	  std::vector<double> data_cov;
	  std::vector<double> chisq_fit_x;
	  std::vector<double> chisq_fit_y;
	  PsrthymeMatrix::Ptr amp_cvm;
	  uint64_t nfree;
	  uint64_t nfit;
	  double phase;
	  double error;
	  double chisq;
      bool failed;
	  PsrthymeResult() {
          this->failed=false;
	  };
	  std::vector<double> best_profile;
	  std::vector<double> residual;
	  void chisqZoom(double cntr, double hwidth, std::vector<double> &x, std::vector<double> &y);
	  void chisqZoomY(double maxval, std::vector<double> &x, std::vector<double> &y);
	  void chisqZoomY(double maxval, std::vector<double> &x, std::vector<double> &y, bool nogaps);
	  void reduceChisq(std::vector<double> &c){
		 for (uint64_t i=0; i < c.size(); i++){
			c[i] /= double(this->nfree);
		 }
	  }
	  PsrthymeToA getToA() const ;
	  static double correctPhase(double p){
		 while (p <= -0.5)p+=1.0;
		 while (p  >  0.5)p-=1.0;
		 return p;
	  }
};
#endif


void PsrthymeResult::chisqZoomY(double maxval, std::vector<double> &x, std::vector<double> &y){
   this->chisqZoomY(maxval,x,y,false);
}
void PsrthymeResult::chisqZoomY(double maxval, std::vector<double> &x, std::vector<double> &y, bool nogaps){
   std::vector<double> full_x;
   std::vector<double> full_y;
   uint64_t ctr = this->chisq_space->toArray(full_x,full_y,this->phase);

   if(nogaps){
	  uint64_t idx=ctr;
	  double prev=full_y[ctr];
	  while(idx > 0 && full_y[idx] < maxval && (ctr-idx < 3 || full_y[idx] > prev)){
		 prev=full_y[idx];
		 idx--;
	  }
	  idx++;
	  while (idx < full_y.size() && full_y[idx] < maxval){
		 assert(idx < full_y.size());
		 assert(idx >=0);
		 if (idx > ctr && full_y[idx] < prev)break;
		 prev=full_y[idx];
		 x.push_back(full_x[idx]);
		 y.push_back(full_y[idx]);
		 idx++;
	  }
   } else {
	  for (uint64_t i = 0; i < full_x.size(); i++){
		 if ( full_y[i] < maxval){
			x.push_back(full_x[i]);
			y.push_back(full_y[i]);
		 }
	  }
   }
}
void PsrthymeResult::chisqZoom(double cntr, double hwidth, std::vector<double> &x, std::vector<double> &y){
   std::vector<double> full_x;
   std::vector<double> full_y;
   this->chisq_space->toArray(full_x,full_y,cntr);
   for (uint64_t i = 0; i < full_x.size(); i++){
	  double phase = PsrthymeResult::correctPhase(full_x[i] - cntr);
	  if ( fabs(phase) < hwidth ){
		 x.push_back(phase);
		 y.push_back(full_y[i]);
	  }
   }
}


/*
 * double period = subint->get_folding_period();
 *
 *   // epoch of the integration (rise time of bin 0 in each profile)
 *     MJD epoch = subint->get_epoch ();
 *
 *       // arrival time 
 *         toa.set_arrival (epoch + shift.get_value() * period);
 *
 *           // arrival time error in microseconds
 *             toa.set_error (shift.get_error() * period * 1e6);
 */
PsrthymeToA PsrthymeResult::getToA() const{
   double period = this->obsn->getPeriod();
   PsrthymeToA ret(
		 this->obsn->getName(),
		 this->obsn->getEpoch() + this->phase*period,
		 this->error*period,
		 this->obsn->getFreq(),
		 this->obsn->getTelescope()
		 );

   boost::format format("%.3f");
   double scale=1.0/this->amp_values[0];
   for (uint64_t i =0; i < this->tmpl->size(); ++i){
	  format % (scale*this->amp_values[i]);
	  ret.setFlag(this->tmpl->at(i)->getName(),format.str());
   }

   return ret;

}


