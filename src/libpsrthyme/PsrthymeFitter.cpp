//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>
#include <TKcholesky.h>
#include <TKfit.h>
#include <TKlog.h>
#include <cmath>
#include <limits>
#include <map>
#include <boost/foreach.hpp>

// include header generated by makeheaders
#include "PsrthymeFitter.hpp"
#define TIMEIT 1

#if INTERFACE
#include <list>
#include <boost/shared_ptr.hpp>

class PsrthymeFitter : public PsrthymeGenericFitter {
   private:
	  struct Iteration{
		 uint64_t resolution;
		 bool cholesky;
		 bool zoom;
		 bool matched_filter;
		 Iteration(uint64_t resolution, bool cholesky, bool zoom){
			this->resolution = resolution;
			this->cholesky = cholesky;
			this->zoom = zoom;
			this->matched_filter=true;
		 }
	  };
	  PsrthymeTemplate::Ptr tmpl;
	  std::list<Iteration> iterations;

	  static double estimate_error(PsrthymeResult::Ptr result);
   public:

	  static double diff(double a, double b){
		 return (a-b);
	  }

	  typedef boost::shared_ptr<PsrthymeFitter> Ptr;
	  PsrthymeFitter() {
		 this->useDefaults();
	  } 
	  void setTemplate(PsrthymeTemplate::Ptr tmpl){
		 this->tmpl = tmpl;
	  }
	  void useDefaults(){
		 this->clear();
		 this->iterations.push_front(Iteration(32,true,true));
		 this->iterations.push_front(Iteration(8,true,true));
		 this->iterations.push_front(Iteration(2,true,false));
		 this->iterations.push_front(Iteration(2,true,false));
		 this->iterations.push_front(Iteration(2,false,false));
	  }
	  void clear(){
		 this->iterations.clear();
	  }
	  void addIteration(uint64_t res, bool cholesky, bool zoom){
		 this->iterations.push_back(Iteration(res,cholesky,zoom));
	  }
	  PsrthymeResult::Ptr fitTo(PsrthymeProfile::Ptr obs);
};

#endif

typedef boost::shared_ptr<mjk_clock_t> clk;

double PsrthymeFitter::estimate_error(PsrthymeResult::Ptr result) {
   double best_phase = result->phase;
   double best_chisq = result->chisq;

   logdbg("Estimate error");
   double error_estimate=0;
   // get error estimate
   {
	  std::vector<double> x,y;
	  double chisq_mult=2;
	  result->chisqZoomY(best_chisq*chisq_mult, x,y,true);
	  while(x.size() < 3){
		 chisq_mult*=1.1;
		 x.clear();
		 y.clear();
		 result->chisqZoomY(best_chisq*chisq_mult, x,y,true);
	  }
	  //debug::plot(y,"y");

	  assert(y.size() >=3);

	  logdbg("Got %d points for fit",x.size());
	  BOOST_FOREACH (double & i, x){
		 i = PsrthymeResult::correctPhase(i-best_phase);
	  }
	  BOOST_FOREACH (double & i, y){
		 i = (i-best_chisq);
	  }

	  std::vector<double> P;
	  P.resize(2);
	  P[0]=0;
	  P[1]=0;
	  logdbg("Fit parabola to chisq");
	  TKleastSquares_svd_noErr(arr(x),arr(y),x.size(), arr(P), 2, psrthyme_err_fit);
	  double A = P[0];
	  double B = P[1];
	  double fit_phase = -B/(2*A);
	  double fit_min = -B*B/(4*A);

	  logdbg("Parabola was no good, constraining fit");
	  if(fit_min < -0.5*best_chisq){
		 TKleastSquares_svd_noErr(arr(x),arr(y),x.size(), arr(P), 1, psrthyme_err_fit);
		 A=P[0];
		 B=0;
		 double fit_phase = -B/(2*A);
		 double fit_min = -B*B/(4*A);
	  }
	  logdbg("fit_min = %lf fit_p = %lf A= %lf B=%lf",fit_min,fit_phase,A,B);
	  error_estimate = (-B + sqrt(B*B + 4.0 * A * best_chisq))/(2.0*A);
	  error_estimate -= fit_phase;
	  if(error_estimate > 0.5)error_estimate=0.5;
	  result->chisq_fit_x.clear();
	  result->chisq_fit_y.clear();
	  for(double p = -error_estimate; p < error_estimate; p+=error_estimate/25.0){
		 double pp = p;//+fit_phase;
		 result->chisq_fit_x.push_back(pp);
		 result->chisq_fit_y.push_back(A*pp*pp +B*pp + best_chisq);
	  }
   }
   return error_estimate;


}


std::vector<double> getCovarianceFunction (const std::vector<double> &profile){
   uint64_t i,j;
   const uint64_t nbins = profile.size();
   std::vector<double> cov(profile);
   double mean=0;
   for(i = 0; i < nbins; i++){
	  mean+=profile[i];
	  cov[i]=0;
   }
   mean /= double(nbins);
   for(j = 0; j < nbins; j++){
	  for(i = 0; i < nbins; i++){
		 cov[j] += (profile[i]-mean)*(profile[(i+j)%nbins]-mean);
	  }
   }
   for(i = 0; i < nbins; i++){
	  cov[i] /= double(nbins);
   }

   return cov;
}



PsrthymeResult::Ptr PsrthymeFitter::fitTo(PsrthymeProfile::Ptr obs){
   if (!obs){
	  logerr("null pointer passed for observation. Perhaps the file could not be read?");
	  exit(1);
   }

   if (!this->tmpl){
	  logerr("null pointer passed for template. Perhaps the file could not be read");
	  exit(1);
   }

   PsrthymeResult::Ptr result = PsrthymeResult::Ptr(new PsrthymeResult());

   std::list<Iteration> itrs(this->iterations);
   const uint64_t nbins = obs->getNbins();
   const uint64_t nfit = this->tmpl->size()+1;
   std::vector<double> residuals(obs->getNormalisedProfile());
   std::vector<double> best_profile;
   best_profile.resize(residuals.size());
   best_profile[0]=1.0;
   PsrthymeMatrix::Ptr outCVM = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nfit));
   boost::shared_ptr<double[]> outP(new double[nfit]);
   boost::shared_ptr<double[]> outErr(new double[nfit]);

   PsrthymeMatrix::Ptr bestCVM = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nfit));
   boost::shared_ptr<double[]> bestP(new double[nfit]);
   boost::shared_ptr<double[]> bestErr(new double[nfit]);

   const double tol = 1.0e-27;

   SparseList::Ptr chisq_space = SparseList::Ptr(new SparseList(0,1,8));
   chisq_space->insert(0,1e99);

   double best_chisq = std::numeric_limits<double>::max();
   double best_phase = 0;

#ifdef TIMEIT
   clk timer_all = clk(init_clock());
   clk timer_uinv = clk(init_clock());
   clk timer_fit = clk(init_clock());
   clk timer_init = clk(init_clock());
   clk timer_itr = clk(init_clock());
   clk timer_multmatrix = clk(init_clock());
   clk timer_matrixvec = clk(init_clock());
   start_clock(timer_all.get());
#endif

   std::vector<double> cov;
   while(itrs.size() > 0){
	  logmsg("Processing '%s' iteration %ld/%ld",obs->getName().c_str(), 1+this->iterations.size() - itrs.size(),this->iterations.size());
	  Iteration itr = itrs.front();
	  itrs.pop_front();

	  const uint64_t nphase_steps = nbins * itr.resolution;

	  if(itr.zoom){
		 double err = PsrthymeFitter::estimate_error(result);
		 double elim = 16.0/double(nphase_steps);
		 if(err > elim){
			logmsg("Ending early as the error is very large,... not worth digging in further!");
			break;
		 }
	  }

#ifdef TIMEIT
	  reset_clock(timer_itr.get());
	  start_clock(timer_itr.get());
	  start_clock(timer_uinv.get());
#endif


	  const double prev_best_phase=chisq_space->min();
	  const double prev_best_chisq=chisq_space->get(prev_best_phase);
	  const double chisq_cut = prev_best_chisq*3.0;
	  std::map<uint64_t, std::vector<double> > yvals;
	  std::map<uint64_t, std::vector<double> > white_yvals;

	  best_chisq = std::numeric_limits<double>::max();
	  best_phase = 0;
	  std::map<uint64_t, PsrthymeMatrix::Ptr > designMatricies;

	  std::map<uint64_t, PsrthymeMatrix::Ptr > white_designMatricies;
	  PsrthymeMatrix::Ptr mconv = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins));

	  //debug::plot(residuals,"raw residuals");
	  if (itr.matched_filter){
		 std::vector<double> matched_filter = best_profile;

		 double alpha = 0;
		 for (int64_t i=0; i < nbins; i++){
			alpha+=(best_profile[i]*matched_filter[i]);
		 }

		 alpha = 1.0/sqrt(alpha);

		 for (int64_t i=0; i < nbins; i++){
			matched_filter[i] *= alpha;
		 }

		 for (int64_t i=0; i < nbins; i++){
			for (int64_t j=0; j < nbins; j++){
			   int64_t k = i-j;
			   if (k<0)k+=nbins;
			   (*mconv)[i][j] = matched_filter[k];
			}
		 }

		 residuals = mconv*residuals;
	  }

	  //debug::plot(residuals,"filtered residuals");

	  PsrthymeMatrix::Ptr covMatrix = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins));
	  cov = getCovarianceFunction(residuals);
	  logdbg("var(data) = %lf",cov[0]);
	  if (itr.cholesky) {
		 cov[0]*=(1+1e-4);
		 covMatrix->addCVF(cov);
	  } else {
		 covMatrix->addDiagonal(cov[0]);
	  }

	  logdbg("cut = %lf",chisq_cut);
	  PsrthymeMatrix::Ptr uinv = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins));
	  cholesky_formUinv(uinv->c_arr(),covMatrix->c_arr(), nbins);

	  //debug::plot(mconv*obs->getNormalisedProfile(),"pre fit filtered");
	  //debug::plot(uinv*obs->getNormalisedProfile(),"pre fit white");

	  if (itr.matched_filter){
		 uinv = uinv*mconv;
	  }


	  //debug::plot(uinv*obs->getNormalisedProfile(),"pre fit white filtered");
	  chisq_space->setResolution(nphase_steps);


#ifdef TIMEIT
	  stop_clock(timer_uinv.get());
#endif
	  for(uint64_t iphase = 0; iphase < nphase_steps; iphase++){

#ifdef TIMEIT
		 start_clock(timer_init.get());
#endif
		 double phase = PsrthymeResult::correctPhase(double(iphase)/double(nphase_steps)); 
		 if(!itr.zoom || chisq_space->get(phase) < chisq_cut){
			logdbg("%lf %lf",phase,chisq_space->get(phase));
			// we want to re-do this bin!
			uint64_t ibin = iphase/itr.resolution;
			uint64_t sbin = iphase-ibin*itr.resolution;

#ifdef TIMEIT
	  start_clock(timer_matrixvec.get());
#endif
			if ( yvals.count(ibin) == 0 ) {
			   // need to generate the rotated profile
			   std::vector<double> rotated(obs->getNormalisedProfile());
			   std::rotate(rotated.begin(),rotated.begin()+ibin,rotated.end());
			   white_yvals[ibin] = uinv*rotated;
			   yvals[ibin] = rotated;
			}

#ifdef TIMEIT
	  stop_clock(timer_matrixvec.get());
	  start_clock(timer_multmatrix.get());
#endif
			if ( designMatricies.count(sbin) == 0 ) {
			   // need to generate the DM for this sub-phase
			   PsrthymeMatrix::Ptr dm = this->tmpl->getDesignMatrix(nbins,double(sbin)/double(nphase_steps));
			   PsrthymeMatrix::Ptr wdm = (*uinv)*dm;
			   designMatricies[sbin] = dm;
			   white_designMatricies[sbin] = wdm;
			}

			/*
			 * double TKleastSquares(double* b, double* white_b,
			 *       double** designMatrix, double** white_designMatrix,
			 *             int n,int nf, double tol, char rescale_errors,
			 *                   double* outP, double* e, double** cvm)
			 */

#ifdef TIMEIT
	  stop_clock(timer_multmatrix.get());
	  stop_clock(timer_init.get());
	  start_clock(timer_fit.get());
#endif

			double chisq = TKleastSquares(arr(yvals[ibin]),arr(white_yvals[ibin]),
				  designMatricies[sbin]->c_arr(),white_designMatricies[sbin]->c_arr(),
				  nbins,nfit,tol,1,arr(outP),arr(outErr),outCVM->c_arr());
			chisq_space->insert(phase,chisq);
			if(chisq < best_chisq) {
			   logdbg("phase %lf chisq %lg",phase,chisq);
			   best_profile = (*designMatricies[sbin])*outP;
			   std::rotate(best_profile.begin(),best_profile.end()-ibin,best_profile.end());
			   best_chisq = chisq;
			   best_phase = phase;
			   bestP.swap(outP);
			   bestCVM.swap(outCVM);
			   bestErr.swap(outErr);
			}

#ifdef TIMEIT
	  stop_clock(timer_fit.get());
#endif

		 }
	  }


	  result->chisq_space = chisq_space;
	  result->phase=best_phase;
	  result->chisq = best_chisq;
	  std::transform(obs->getNormalisedProfile().begin(), obs->getNormalisedProfile().end(),
			best_profile.begin(), residuals.begin(), PsrthymeFitter::diff);

#ifdef TIMEIT
	  stop_clock(timer_itr.get());
	  logmsg("T(itr) = %lg",read_clock(timer_itr.get()));
#endif
   }


#ifdef TIMEIT
   logmsg("T(uinv) = %lg",read_clock(timer_uinv.get()));
   logmsg("T(init) = %lg",read_clock(timer_init.get()));
   logmsg("T(M*M) = %lg",read_clock(timer_multmatrix.get()));
   logmsg("T(M*V) = %lg",read_clock(timer_matrixvec.get()));
   logmsg("T(fit) = %lg",read_clock(timer_fit.get()));
   clk timer_err = clk(init_clock());
   start_clock(timer_err.get());
#endif

   result->tmpl = this->tmpl;
   result->obsn = obs;
   result->amp_values = std::vector<double>(arr(bestP),arr(bestP)+nfit);
   result->amp_errors = std::vector<double>(arr(bestErr),arr(bestErr)+nfit);
   result->amp_cvm = bestCVM;
   result->data_cov = cov;
   result->residual = residuals;
   result->best_profile = best_profile;
   result->nfree=nbins-nfit-1;
   result->nfit=nfit;
   result->phase=best_phase;
   result->chisq = best_chisq;

   result->error=PsrthymeFitter::estimate_error(result);

#ifdef TIMEIT
   stop_clock(timer_err.get());
   stop_clock(timer_all.get());
   logmsg("T(err) = %lg",read_clock(timer_err.get()));
   logmsg("T(all) = %lg",read_clock(timer_all.get()));
#endif

   return result;
}

extern "C" void psrthyme_err_fit(double x, double *v,int m){
   if(m==1){
	  v[0]=x*x;
   } else if(m==2){
	  v[0] = x*x;
	  v[1] = x;
   } else {
	  logerr("m=%d???",m);
	  exit(1);
   }
}


