//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>
#include <TKcholesky.h>
#include <TKfit.h>
#include <TKlog.h>
#include <cmath>
#include <limits>
#include <map>
#include <boost/foreach.hpp>

// include header generated by makeheaders
#include "PsrthymeFitter.hpp"

#if INTERFACE
#include <list>
#include <boost/shared_ptr.hpp>

class PsrthymeFitter {
   private:
	  struct Itteration{
		 uint64_t resolution;
		 bool cholesky;
		 bool zoom;
		 Itteration(uint64_t resolution, bool cholesky, bool zoom){
			this->resolution = resolution;
			this->cholesky = cholesky;
			this->zoom = zoom;
		 }
	  };
	  PsrthymeTemplate::Ptr tmpl;
	  std::list<Itteration> itterations;
   public:
	  typedef boost::shared_ptr<PsrthymeFitter> Ptr;
	  PsrthymeFitter() {
		 this->useDefaults();
	  } 
	  void setTemplate(PsrthymeTemplate::Ptr tmpl){
		 this->tmpl = tmpl;
	  }
	  void useDefaults(){
		 this->clear();
		 this->itterations.push_front(Itteration(32,true,true));
		 this->itterations.push_front(Itteration(8,true,true));
		 this->itterations.push_front(Itteration(1,true,false));
		 this->itterations.push_front(Itteration(1,true,false));
		 this->itterations.push_front(Itteration(1,false,false));
	  }
	  void clear(){
		 this->itterations.clear();
	  }
	  void addItteration(uint64_t res, bool cholesky, bool zoom){
		 this->itterations.push_back(Itteration(res,cholesky,zoom));
	  }
	  PsrthymeResult::Ptr fitTo(PsrthymeProfile::Ptr obs);
};

#endif

std::vector<double> getCovarianceFunction (const std::vector<double> &profile){
   uint64_t i,j;
   const uint64_t nbins = profile.size();
   std::vector<double> cov(profile);
   double mean=0;
   for(i = 0; i < nbins; i++){
	  mean+=profile[i];
	  cov[i]=0;
   }
   LOGDBG << "nbins="<<nbins <<std::endl;
   LOGDBG << "mean="<<mean <<std::endl;
   mean /= double(nbins);
   for(j = 0; j < nbins; j++){
	  for(i = 0; i < nbins; i++){
		 cov[j] += (profile[i]-mean)*(profile[(i+j)%nbins]-mean);
	  }
   }
   for(i = 0; i < nbins; i++){
	  cov[i] /= double(nbins);
   }

   return cov;
}



PsrthymeResult::Ptr PsrthymeFitter::fitTo(PsrthymeProfile::Ptr obs){
   std::list<Itteration> ittrs(this->itterations);
   const uint64_t nbins = obs->getNbins();
   const uint64_t nfit = this->tmpl->size()+1;
   std::vector<double> residuals(obs->profile);
   std::vector<double> best_profile(obs->profile);
   LOGDBG << "nit = " << ittrs.size() << std::endl;
   PsrthymeMatrix::Ptr outCVM = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nfit));
   boost::shared_ptr<double[]> outP(new double[nfit]);
   boost::shared_ptr<double[]> outErr(new double[nfit]);

   PsrthymeMatrix::Ptr bestCVM = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nfit));
   boost::shared_ptr<double[]> bestP(new double[nfit]);
   boost::shared_ptr<double[]> bestErr(new double[nfit]);

   const double tol = 1.0e-27;

   SparseList::Ptr chisq_space = SparseList::Ptr(new SparseList(0,1,8));
   chisq_space->insert(0,1e99);

   double best_chisq = std::numeric_limits<double>::max();
   double best_phase = 0;

   std::vector<double> cov;
   while(ittrs.size() > 0){
	  Itteration itr = ittrs.front();
	  ittrs.pop_front();
	  LOGDBG << "nit = " << ittrs.size() << std::endl;
	  const uint64_t nphase_steps = nbins * itr.resolution;
	  const double prev_best_phase=chisq_space->min();
	  LOGDBG << "prev_phase = " << prev_best_phase << std::endl;
	  const double prev_best_chisq=chisq_space->get(prev_best_phase);
	  LOGDBG << "prev_chisq = " << prev_best_chisq << std::endl;
	  const double chisq_cut = prev_best_chisq*3.0;
	  std::map<uint64_t, std::vector<double> > yvals;
	  std::map<uint64_t, std::vector<double> > white_yvals;

	  best_chisq = std::numeric_limits<double>::max();
	  best_phase = 0;
	  std::map<uint64_t, PsrthymeMatrix::Ptr > designMatricies;
	  std::map<uint64_t, PsrthymeMatrix::Ptr > white_designMatricies;

	  LOGDBG << "Alloc UINV " << std::endl;
	  LOGDBG << "Get covar function" << std::endl;
	  PsrthymeMatrix::Ptr covMatrix = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins));
	  cov = getCovarianceFunction(residuals);
	  logdbg("var(data) = %lf",cov[0]);
	  if (itr.cholesky) {
		 cov[0]*=(1+1e-4);
		 covMatrix->addCVF(cov);
	  } else {
		 covMatrix->addDiagonal(cov[0]);
	  }

	  logdbg("cut = %lf",chisq_cut);
	  PsrthymeMatrix::Ptr uinv = PsrthymeMatrix::Ptr(new PsrthymeMatrix(nbins));
	  cholesky_formUinv(uinv->c_arr(),covMatrix->c_arr(), nbins);


	  chisq_space->setResolution(nphase_steps);

	  for(uint64_t iphase = 0; iphase < nphase_steps; iphase++){
		 double phase = PsrthymeResult::correctPhase(double(iphase)/double(nphase_steps)); 
		 if(!itr.zoom || chisq_space->get(phase) < chisq_cut){
			logdbg("%lf %lf",phase,chisq_space->get(phase));
			// we want to re-do this bin!
			uint64_t ibin = iphase/itr.resolution;
			uint64_t sbin = iphase-ibin*itr.resolution;
			if ( yvals.count(ibin) == 0 ) {
			   // need to generate the rotated profile
			   //	   LOGDBG << "make rotprof for "<< ibin << std::endl;
			   std::vector<double> rotated(obs->profile);
			   std::rotate(rotated.begin(),rotated.begin()+ibin,rotated.end());
			   white_yvals[ibin] = (*uinv)*rotated;
			   yvals[ibin] = rotated;
			}
			if ( designMatricies.count(sbin) == 0 ) {
			   // need to generate the DM for this sub-phase
			   //	   LOGDBG << "make dm for "<< sbin << std::endl;
			   PsrthymeMatrix::Ptr dm = this->tmpl->getDesignMatrix(nbins,double(sbin)/double(nphase_steps));
			   PsrthymeMatrix::Ptr wdm = (*uinv)*dm;
			   designMatricies[sbin] = dm;
			   white_designMatricies[sbin] = wdm;
			}

			/*
			 * double TKleastSquares(double* b, double* white_b,
			 *       double** designMatrix, double** white_designMatrix,
			 *             int n,int nf, double tol, char rescale_errors,
			 *                   double* outP, double* e, double** cvm)
			 */

			double chisq = TKleastSquares(arr(yvals[ibin]),arr(white_yvals[ibin]),
				  designMatricies[sbin]->c_arr(),white_designMatricies[sbin]->c_arr(),
				  nbins,nfit,tol,1,arr(outP),arr(outErr),outCVM->c_arr());
			chisq_space->insert(phase,chisq);
			if(chisq < best_chisq) {
			   logdbg("phase %lf chisq %lg",phase,chisq);
			   best_profile = (*designMatricies[sbin])*outP;
			   std::rotate(best_profile.begin(),best_profile.end()-ibin,best_profile.end());
			   best_chisq = chisq;
			   best_phase = phase;
			   bestP.swap(outP);
			   bestCVM.swap(outCVM);
			   bestErr.swap(outErr);
			}
		 }
	  }

	  std::transform(obs->profile.begin(), obs->profile.end(),
			best_profile.begin(), residuals.begin(), diff);
   }

   PsrthymeResult::Ptr result = PsrthymeResult::Ptr(new PsrthymeResult());
   result->chisq_space = chisq_space;
   result->tmpl = this->tmpl;
   result->obsn = obs;
   result->amp_values = std::vector<double>(arr(bestP),arr(bestP)+nfit);
   result->amp_errors = std::vector<double>(arr(bestErr),arr(bestErr)+nfit);
   result->amp_cvm = bestCVM;
   result->data_cov = cov;
   result->phase=best_phase;
   result->residual = residuals;
   result->best_profile = best_profile;
   result->nfree=nbins-nfit-1;
   result->nfit=nfit;
   result->chisq = best_chisq;


   double error_estimate=0;
// get error estimate
   {
	  std::vector<double> x,y;
	  double chisq_mult=2;
	  result->chisqZoomY(best_chisq*chisq_mult, x,y);
	  while(x.size() < 3){
		 chisq_mult*=1.1;
		 x.clear();
		 y.clear();
		 result->chisqZoomY(best_chisq*chisq_mult, x,y);
	  }
	  BOOST_FOREACH (double & i, x){
		 i = PsrthymeResult::correctPhase(i-best_phase);
		 logmsg("x %lf",i);
	  }
	  BOOST_FOREACH (double & i, y){
		 i = (i-best_chisq);
		 logmsg("y %lf",i);
	  }

	  std::vector<double> P;
	  P.resize(2);
	  P[0]=0;
	  P[1]=0;
	  TKleastSquares_svd_noErr(arr(x),arr(y),x.size(), arr(P), 2, psrthyme_err_fit);
	  double A = P[0];
	  double B = P[1];
	  double fit_phase = -B/(2*A);
	  double fit_min = -B*B/(4*A);
	  if(fit_min < -0.5*best_chisq){
		 TKleastSquares_svd_noErr(arr(x),arr(y),x.size(), arr(P), 1, psrthyme_err_fit);
		 A=P[0];
		 B=0;
		 double fit_phase = -B/(2*A);
		 double fit_min = -B*B/(4*A);
	  }
	  logmsg("fit_min = %lf fit_p = %lf A= %lf B=%lf",fit_min,fit_phase,A,B);
	  error_estimate = (-B + sqrt(B*B + 4.0 * A * best_chisq))/(2.0*A);
	  error_estimate -= fit_phase;
	  if(error_estimate > 0.5)error_estimate=0.5;
	  for(double p = -error_estimate; p < error_estimate; p+=error_estimate/25.0){
		 double pp = p+fit_phase;
		 result->chisq_fit_x.push_back(pp);
		 result->chisq_fit_y.push_back(A*pp*pp +B*pp + best_chisq);
	  }
	  result->phase +=fit_phase;
   }

   result->error=error_estimate;

   return result;
}

double diff(double a, double b){
   return (a-b);
}

extern "C" void psrthyme_err_fit(double x, double *v,int m){
   if(m==1){
	  v[0]=x*x;
   } else if(m==2){
	  v[0] = x*x;
	  v[1] = x;
   } else {
	  logmsg("m=%d???",m);
   }
}
