//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <boost/lexical_cast.hpp>
#include <fstream>

// include header generated by makeheaders
#include "PsrthymeProfile.hpp"

#if INTERFACE
#include <vector>
#include <string>
#include <iostream>
#include <Pulsar/Profile.h>
#include <boost/shared_ptr.hpp>
class PsrthymeProfile {
   public:
	  typedef boost::shared_ptr<PsrthymeProfile> Ptr;
	  typedef Pulsar::Profile* Chive;
   private:
	  Chive chive;
	  std::vector<double> profile;
	  std::vector<double> phase;
	  PsrthymeProfile(){};
   public:
	  Chive getChive(){
		 return this->chive;
	  }
	  const std::vector<double> &getProfile() const{
		 return this->profile;
	  }

	  const std::vector<double> &getPhase();
	  uint64_t getNbins(){
		 return this->profile.size();
	  }

	  PsrthymeProfile(Chive chive);

	  static Ptr readASCII(std::string in);
	  static Ptr readASCII(std::istream &in);
	  friend Ptr readASCII(std::istream &in);
};
#endif

PsrthymeProfile::PsrthymeProfile(Chive chive){
   this->chive   = chive;
   chive->get_amps(this->profile);
   uint64_t nbins = this->profile.size();
   for(uint64_t ibin=0; ibin<nbins; ibin++){
	  double iphase = PsrthymeResult::correctPhase(double(ibin)/double(nbins));
	  this->phase.push_back(iphase);
   }
}


PsrthymeProfile::Ptr PsrthymeProfile::readASCII(std::string in){
   std::ifstream stream(in.c_str());
   return PsrthymeProfile::readASCII(stream);
}
PsrthymeProfile::Ptr PsrthymeProfile::readASCII(std::istream &in){
   PsrthymeProfile::Ptr prof = PsrthymeProfile::Ptr(new PsrthymeProfile());
   std::string line;
   while (std::getline(in, line)) {
	  try {
		 double x = boost::lexical_cast<double>(line); // double could be anything with >> operator.
		 prof->profile.push_back(x);
	  } catch (...){
		 continue;
	  }
   }

   return prof;
}

const std::vector<double> &PsrthymeProfile::getPhase() {
   if (this->phase.size()!=this->profile.size()){
	  const uint64_t nbins=this->getNbins();
	  for(uint64_t ibin=0; ibin<nbins; ibin++){
		 double iphase = PsrthymeResult::correctPhase(double(ibin)/double(nbins));
		 this->phase.push_back(iphase);
	  }
   }
   return this->phase;
}

