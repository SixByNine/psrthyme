//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <boost/lexical_cast.hpp>
#include <fstream>
#include <algorithm>

// include header generated by makeheaders
#include "PsrthymeProfile.hpp"

#if INTERFACE
#include <vector>
#include <string>
#include <iostream>
#include <Pulsar/Integration.h>
#include <Pulsar/Profile.h>
#include <boost/shared_ptr.hpp>
class PsrthymeProfile {
   public:
	  typedef boost::shared_ptr<PsrthymeProfile> Ptr;
	  typedef Pulsar::Integration* Chive;


   private:

	  uint64_t ichan;
	  uint64_t ipol;
	  Chive chive;
	  std::vector<double> profile;
	  std::vector<double> normprofile;
	  std::vector<double> phase;
	  PsrthymeTelescope::Ptr telescope;
	  PsrthymeProfile(){
		 this->chive = Chive(0);
	  };
   public:
	  Chive getChive(){
		 return this->chive;
	  }
	  const std::vector<double> &getProfile() const{
		 return this->profile;
	  }
	  const std::vector<double> &getNormalisedProfile();

	  const std::vector<double> &getPhase();
	  uint64_t getNbins() const {
		 return this->profile.size();
	  }
	  PsrthymeTelescope::Ptr getTelescope(){
		 return this->telescope;
	  }
	  double getFreq(){
		 if(this->chive->get_dedispersed()){
		 return this->chive->get_centre_frequency();
		 } else{
		 return this->chive->get_centre_frequency(this->ichan);
		 }
	  }

	  double getPeriod() const {
		 if(this->chive == 0) return 0;
		 else return this->chive->get_folding_period();
	  }
	  MJD getEpoch() const {
		 if(this->chive == 0) return MJD(55000.0);
		 else return this->chive->get_epoch();
	  }


	  PsrthymeProfile(Chive chive,uint64_t ipol, uint64_t ichan, PsrthymeTelescope::Ptr telescope);

	  static Ptr readASCII(std::string in);
	  static Ptr readASCII(std::istream &in);
	  friend Ptr readASCII(std::istream &in);
};
#endif

PsrthymeProfile::PsrthymeProfile(Chive chive,uint64_t ipol, uint64_t ichan, PsrthymeTelescope::Ptr telescope){
   this->ichan=ichan;
   this->ipol=ipol;
   this->chive = chive; 
   this->telescope = telescope;
   chive->get_Profile(ipol,ichan)->get_amps(this->profile);
   uint64_t nbins = this->profile.size();
   for(uint64_t ibin=0; ibin<nbins; ibin++){
	  double iphase = PsrthymeResult::correctPhase(double(ibin)/double(nbins));
	  this->phase.push_back(iphase);
   }
}


PsrthymeProfile::Ptr PsrthymeProfile::readASCII(std::string in){
   std::ifstream stream(in.c_str());
   return PsrthymeProfile::readASCII(stream);
}
PsrthymeProfile::Ptr PsrthymeProfile::readASCII(std::istream &in){
   PsrthymeProfile::Ptr prof = PsrthymeProfile::Ptr(new PsrthymeProfile());
   std::string line;
   while (std::getline(in, line)) {
	  try {
		 double x = boost::lexical_cast<double>(line); // double could be anything with >> operator.
		 prof->profile.push_back(x);
	  } catch (...){
		 continue;
	  }
   }

   return prof;
}

const std::vector<double> &PsrthymeProfile::getNormalisedProfile() {
   if (this->normprofile.size()!=this->profile.size()){
	  const uint64_t nbins=this->getNbins();
	  double max = *std::max_element(this->profile.begin(),this->profile.end());
	  double min = *std::min_element(this->profile.begin(),this->profile.end());
	  for(uint64_t ibin=0; ibin<nbins; ibin++){
		 double inormprofile = (this->profile[ibin]-min)/(max-min);
		 this->normprofile.push_back(inormprofile);
	  }
   }
   return this->normprofile;
}

const std::vector<double> &PsrthymeProfile::getPhase() {
   if (this->phase.size()!=this->profile.size()){
	  const uint64_t nbins=this->getNbins();
	  for(uint64_t ibin=0; ibin<nbins; ibin++){
		 double iphase = PsrthymeResult::correctPhase(double(ibin)/double(nbins));
		 this->phase.push_back(iphase);
	  }
   }
   return this->phase;
}


