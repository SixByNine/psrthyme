//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include "levmar/levmar.h"
#include <TKlog.h>

// include header generated by makeheaders
#include "LevMar.hpp"

#if EXPORT_INTERFACE
#include <boost/shared_ptr.hpp>
#include <vector>
#define LM_INFO_SZ 10
#define LM_INFO_CHISQ 1

class LevMar {
   private:
	  uint32_t niterations;
   protected:
	  double fit_info[LM_INFO_SZ];
   public:
	  LevMar() {
		 this->niterations=10;
	  }

	  virtual bool hasJacobian(){
		 return false;
	  }
	  virtual std::vector<double> evaluate(const std::vector<double> &p) = 0;
	  virtual std::vector<double> jacobian(const std::vector<double> &p){
		 std::vector<double> ret(0);
		 return ret;
	  }

	  const uint32_t getMaxIterations(){
		 return this->niterations;
	  }
	  void setMaxIterations(uint32_t niterations){
		 this->niterations = niterations;
	  }

	  const PsrthymeMatrix doFit(std::vector<double> &params, const std::vector<double> &yvals);
	  const PsrthymeMatrix doFit(std::vector<double> &params, const std::vector<double> &yvals,
			const std::vector<double> &ub, const std::vector<double> &lb);
};

#endif

using std::vector;
// PRIVATE callback functions to pass to the levmar library
extern "C" void lm_callback_func_d(double *p, double *hx, int m, int n, void *adata);
extern "C" void lm_callback_jacf_d(double *p, double *j, int m, int n, void *adata);

const PsrthymeMatrix LevMar::doFit(vector<double> &params, const vector<double> &yvals){
   PsrthymeMatrix covar(params.size(),params.size());
   vector<double> y(yvals.begin(),yvals.end());
   int nit=0;

   if(this->hasJacobian()){
	  nit=dlevmar_der(lm_callback_func_d,lm_callback_jacf_d,
			&params[0], &y[0],
			params.size(), y.size(),
			this->getMaxIterations(),NULL,this->fit_info,NULL,covar.c_arr()[0],(void*)this);
   } else {
	  nit=dlevmar_dif(lm_callback_func_d,
			&params[0], &y[0],
			params.size(), y.size(),
			this->getMaxIterations(),NULL,this->fit_info,NULL,covar.c_arr()[0],(void*)this);

   }
   logmsg("nit=%d",nit);
   return covar;
}

const PsrthymeMatrix LevMar::doFit(vector<double> &params, const vector<double> &yvals,
	  const vector<double> &_ub, const vector<double> &_lb){
   PsrthymeMatrix covar(params.size(),params.size());
   vector<double> y(yvals.begin(),yvals.end());
   vector<double> lb(_lb.begin(),_lb.end());
   vector<double> ub(_ub.begin(),_ub.end());
	int nit=0;
   if(this->hasJacobian()){
	  nit=dlevmar_bc_der(lm_callback_func_d,lm_callback_jacf_d,
			arr(params), arr(y),
			params.size(), y.size(),
			arr(lb), arr(ub),NULL,
			this->getMaxIterations(),NULL,this->fit_info,NULL,covar.c_arr()[0],(void*)this);
   } else {
	  nit=dlevmar_bc_dif(lm_callback_func_d,
			arr(params), arr(y),
			params.size(), y.size(),
			arr(lb),arr(ub),NULL,
			this->getMaxIterations(),NULL,this->fit_info,NULL,covar.c_arr()[0],(void*)this);

   }

   logmsg("nit=%d",nit);
   return covar;
}



/**
 * Callbacks from C to C++
 */
void lm_callback_func_d(double *p, double *hx, int m, int n, void *adata){
   const vector<double> _p = vector<double>(p,p+m);
   vector<double>_hx = ((LevMar*)adata)->evaluate(_p);
   std::copy(_hx.begin(),_hx.end(),hx);
}
void lm_callback_jacf_d(double *p, double *j, int m, int n, void *adata){
   const vector<double> _p = vector<double>(p,p+m);
   vector<double>_j = ((LevMar*)adata)->jacobian(_p);
   std::copy(_j.begin(),_j.end(),j);
}

