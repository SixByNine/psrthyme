//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>
#include <limits>
#include <cmath>

// include header generated by makeheaders
#include "sparselist.hpp"

#if INTERFACE

#include <vector>
#include <utility>
#include <boost/shared_ptr.hpp>
class SparseList {
   private:
	  uint64_t res;
	  std::vector< std::pair<double,double> > list;
	  double maxval;
	  double minval;
	  void sort();
	  uint64_t indexof(double index);
   public:

	  typedef boost::shared_ptr<SparseList>  Ptr;
	  // inline public methods
	  SparseList(double minval, double maxval, uint64_t res){
		 this->minval=minval;
		 this->maxval=maxval;
		 this->res=res;
	  }
	  uint64_t size(){
		 return this->list.size();
	  }
	  uint64_t getResolution(){
		 return this->res;
	  }
	  void setResolution(const uint64_t res){
		 this->res = res;
	  }
	  double range(){
		 return this->maxval-this->minval;
	  }

	  // library methods
	  double min();
	  double max();
	  double get(const double index);
	  double get(const uint64_t index);
	  void insert(const double index, const double value);
	  void clear(const double from, const double to);
	  void clear(){
		 this->list.clear();
	  }
	  void toArray(double* index, double* values);
	  void toArray(double* index, double* values, double start);
}

#endif

uint64_t SparseList::indexof(const double index){
   this->sort();
   double diff = std::numeric_limits<double>::max();
   uint64_t best_idx=0;
   for (uint64_t i = 0; i < this->list.size(); i++){
	  if(abs(this->list[i].first - index) < diff){
		 diff=fabs(this->list[i].first - index);
		 best_idx=i;
	  }
   }
   return best_idx;
}


double SparseList::min(){
   double diff = std::numeric_limits<double>::max();
   double best_idx=0;
   for (uint64_t i = 0; i < this->list.size(); i++){
	  if(this->list[i].second < diff){
		 diff=this->list[i].second;
		 best_idx=this->list[i].first;
	  }
   }
   return best_idx;
}

double SparseList::max(){
   double diff = -std::numeric_limits<double>::max();
   double best_idx=0;
   for (uint64_t i = 0; i < this->list.size(); i++){
	  if(this->list[i].second > diff){
		 diff=this->list[i].second;
		 best_idx=this->list[i].first;
	  }
   }
   return best_idx;
}

double SparseList::get(const double index){
   return this->list[this->indexof(index)].second;
}
double SparseList::get(const uint64_t index){
   return this->get(double(index)/double(this->res));
}
void SparseList::insert(const double index, const double value){
   this->list.push_back(std::pair<double,double>(index,value));
}
void SparseList::clear(const double from, const double to){
   uint64_t start=0;
   uint64_t end=0;
   this->sort();
   for (uint64_t i = 0; i < this->list.size(); i++){
	  if (this->list[i].first < from){
		 start = i+1;
	  }
	  if (this->list[i].first > to){
		 end = i;
		 break;
	  }
   }
   this->list.erase(this->list.begin()+start,this->list.begin()+end);
}
void SparseList::toArray(double* index, double* values, double centre){
   uint64_t offset = this->indexof(centre - this->range()/2.0);
   uint64_t from_idx=0;
   for(uint64_t idx = 0; idx < this->list.size(); idx++){
	  from_idx = (idx + offset)%this->list.size();
	  index[idx] = this->list[from_idx].first;
	  values[idx] = this->list[from_idx].second;
   }
}
void SparseList::toArray(double* index, double* values){
   for(uint64_t idx = 0; idx < this->list.size(); idx++){
	  index[idx] = this->list[idx].first;
	  values[idx] = this->list[idx].second;
   }
}

void SparseList::sort(){
   std::sort(this->list.begin(), this->list.end());
}
