//  Copyright (C) 2014 Michael J. Keith, University of Manchester
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <inttypes.h>
#include <algorithm>
#include <limits>

// include header generated by makeheaders
#include "sparselist.hpp"

#if INTERFACE

#include <cmath>
#include <map>
#include <vector>
#include <utility>
#include <boost/shared_ptr.hpp>
class SparseList {
   private:
	  uint64_t res;
	  std::map<double,double> values;
	  double maxval;
	  double minval;
   public:

	  typedef boost::shared_ptr<SparseList>  Ptr;
	  // inline public methods
	  SparseList(double minval, double maxval, uint64_t res){
		 this->minval=minval;
		 this->maxval=maxval;
		 this->res=res;
	  }
	  double trimIndex(double index){
		 return this->range() * floor(this->res * (index-this->minval)/this->range()+0.5)/double(this->res) + this->minval;
	  }
	  uint64_t size(){
		 return this->values.size();
	  }
	  uint64_t getResolution(){
		 return this->res;
	  }
	  void setResolution(const uint64_t res){
		 std::map<double,double> old;
		 old.swap(this->values);
		 this->res = res;
		 for (std::map<double,double>::iterator it=old.begin(); it!=old.end(); ++it){
			this->values[trimIndex(it->first)]=it->second;
		 }
	  }
	  double range(){
		 return this->maxval-this->minval;
	  }

	  // library methods
	  double min();
	  double max();
	  double get(const double index);
	  double closest(const double index);
	  void insert(const double index, const double value);
	  void clear(){
		 this->values.clear();
	  }
	  void toArray(double* index, double* values);
	  void toArray(double* index, double* values, double start);
}

#endif

double SparseList::min(){
   double diff = std::numeric_limits<double>::max();
   double best_idx=-1;
   for (std::map<double,double>::iterator it=this->values.begin(); it!=this->values.end(); ++it)
	  if(it->second < diff){
		 diff=it->second;
		 best_idx=it->first;
	  }
   return best_idx;
}


double SparseList::max(){
   double diff = -std::numeric_limits<double>::max();
   double best_idx=-1;
   for (std::map<double,double>::iterator it=this->values.begin(); it!=this->values.end(); ++it)
	  if(it->second > diff){
		 diff=it->second;
		 best_idx=it->first;
	  }
   return best_idx;
}

double SparseList::get(const double index){
   return this->values[this->closest(index)];
}
double SparseList::closest(const double index){
   double diff = std::numeric_limits<double>::max();
   double best=0;
   for (std::map<double,double>::iterator it=this->values.begin(); it!=this->values.end(); ++it)
	  if(abs(it->second - index) < diff){
		 diff=abs(it->second - index);
		 best=it->first;
	  }
   return best;
}

void SparseList::insert(const double index, const double value){
   this->values[trimIndex(index)] = value;
}

void SparseList::toArray(double* index, double* values, double centre){
   uint64_t idx=this->values.size()/2;
   for (std::map<double,double>::iterator it = this->values.find(this->closest(centre)); idx < this->values.size(); ++it){
	  index[idx] = it->first;
	  values[idx] = it->second;
	  if(it == this->values.end()){
		 it=this->values.begin();
	  }
	  idx++;
	  if(idx == this->values.size()){
		 idx=0;
	  }
   }

}
void SparseList::toArray(double* index, double* values){
   uint64_t idx=0;
   for (std::map<double,double>::iterator it=this->values.begin(); it!=this->values.end(); ++it){
	  index[idx] = it->first;
	  values[idx] = it->second;
	  idx++;
   }
}

